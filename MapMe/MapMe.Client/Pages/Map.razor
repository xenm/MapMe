@page "/"
@page "/map"
@using System.Text.Json
@using MapMe.Client.Models
@using MapMe.Client.Services
@using Microsoft.JSInterop
@using System.Net.Http
@using System.Net.Http.Json
@using System.Linq
@using System.Web
@inject IJSRuntime JsRuntime
@inject HttpClient Http
@inject NavigationManager Navigation
@inject UserProfileService ProfileService
@implements IAsyncDisposable

<PageTitle>MapMe</PageTitle>

<div class="page">
    <h1>Map</h1>
    
    <div class="mb-3">
        <Badge Color="BadgeColor.Primary">Interactive Map</Badge>
    </div>

    <div class="card">
        <CardHeader>
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                <CardTitle class="mb-0">Map View</CardTitle>
                <div class="d-flex gap-2">
                    <div class="search-container">
                        <div class="input-group">
                            <input type="text" 
                                   class="form-control" 
                                   placeholder="Search location..." 
                                   @bind="_searchQuery"
                                   @onkeyup="OnSearchKeyUp" />
                            <Button Color="ButtonColor.Primary" 
                                    @onclick="SearchLocation" 
                                    Disabled="@(_isLoading || string.IsNullOrWhiteSpace(_searchQuery))">
                                <i class="bi bi-search"></i>
                            </Button>
                        </div>
                    </div>
                    <Button Color="ButtonColor.Primary" 
                            Outline="true" 
                            Size="ButtonSize.Small" 
                            @onclick="CenterMap" 
                            Disabled="@_isLoading">
                        @(_isLoading ? "Loading..." : "Center Map")
                    </Button>
                </div>
            </div>
        </CardHeader>
        <CardBody>
            @if (_isLoading)
            {
                <div class="d-flex justify-content-center align-items-center" style="height: 600px;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading map...</span>
                    </div>
                    <span class="ms-2">Loading map and getting your location...</span>
                </div>
            }
            <div id="map" style="height: 600px; border-radius: 4px; overflow: hidden; @(_isLoading ? "display: none;" : "") "></div>
        </CardBody>
    </div>

    @if (_showConfirm)
    {
        <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Save Location</h5>
                        <button type="button" class="btn-close" @onclick="CancelConfirm"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <strong>@(_pendingGeo?.Name ?? "Unknown Location")</strong>
                            @if (!string.IsNullOrWhiteSpace(_pendingGeo?.Address))
                            {
                                <div class="text-muted small">@_pendingGeo.Address</div>
                            }
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Note (optional)</label>
                            <textarea class="form-control" rows="3" @bind="_pendingNote" placeholder="Add a note about this place..."></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="CancelConfirm">Cancel</button>
                        <button type="button" class="btn btn-primary" @onclick="ConfirmSave">Save</button>
                    </div>
                </div>
            </div>
        </div>
    }

    <div class="card mt-3">
        <CardHeader>
            <CardTitle class="mb-0">Saved DateMarks (local)</CardTitle>
        </CardHeader>
        <CardBody>
            @if (_savedMarks.Count == 0)
            {
                <div class="text-muted">No marks saved yet. Click on the map or drag the marker to add one.</div>
            }
            else
            {
                <ul class="list-group">
                    @foreach (var mark in _savedMarks)
                    {
                        <li class="list-group-item d-flex justify-content-between align-items-center">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>@(mark.Name ?? "Unnamed Location")</strong>
                                    <div class="text-muted small">@mark.Address</div>
                                    @if (!string.IsNullOrWhiteSpace(mark.Note))
                                    {
                                        <div class="small">@mark.Note</div>
                                    }
                                    <div class="text-muted small">Created by: @mark.UserId</div>
                                </div>
                                <div class="text-end">
                                    <small class="text-muted">@mark.CreatedAt.ToString("MMM dd, yyyy")</small>
                                    <div class="mt-1">
                                        <button class="btn btn-sm btn-outline-primary me-1" @onclick="() => FlyTo(mark)">
                                            <i class="bi bi-geo-alt"></i>
                                        </button>
                                        <button class="btn btn-sm btn-outline-danger" @onclick="() => RemoveMark(mark)">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </li>
                    }
                </ul>
            }
        </CardBody>
    </div>

    <div class="mt-3">
        <Button Color="ButtonColor.Primary" Href="/">Back to Home</Button>
    </div>
</div>

@code {
    private IJSObjectReference? _mapModule;
    private DotNetObjectReference<Map>? _dotNetHelper;
    private double _latitude = 1.3521; // Default to Singapore
    private double _longitude = 103.8198;
    private int _zoom = 11;
    private string _mapType = "roadmap";
    private bool _isLoading = true;
    private bool _isDisposed;
    private string _searchQuery = string.Empty;
    private string? _googleMapsApiKey;
    private const string StorageKey = "dateMarks";
    private readonly List<DateMark> _savedMarks = new();
    private bool _showConfirm;
    private double _pendingLat;
    private double _pendingLng;
    private ReverseGeocodeResult? _pendingGeo;
    private string _pendingNote = string.Empty;
    private UserProfile _currentUserProfile = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadCurrentUserProfile();
            await SetupJavaScriptHooks();
            await HandleQueryParameters();
            await InitializeMap();
        }
    }

    private async Task LoadCurrentUserProfile()
    {
        try
        {
            _currentUserProfile = await ProfileService.GetCurrentUserProfileAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading current user profile: {ex.Message}");
        }
    }

    private async Task SetupJavaScriptHooks()
    {
        try
        {
            // Set up JavaScript hook to get user profiles from Blazor
            var objRef = DotNetObjectReference.Create(this);
            await JsRuntime.InvokeVoidAsync("eval", $@"
                window.MapMe = window.MapMe || {{}};
                window.MapMe._mapInstance = {objRef};
                window.MapMe.getUserProfile = async function(username) {{
                    try {{
                        return await window.MapMe._mapInstance.invokeMethodAsync('GetUserProfileForJS', username);
                    }} catch (e) {{
                        console.log('Error getting user profile:', e);
                        return null;
                    }}
                }};
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error setting up JavaScript hooks: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task<object?> GetUserProfileForJS(string username)
    {
        try
        {
            // Get real user profile data using the UserProfileService
            var userProfile = await ProfileService.GetUserProfileAsync(username);
            if (userProfile != null)
            {
                var activityStats = await ProfileService.GetUserActivityStatsAsync(userProfile.UserId);
                
                return new
                {
                    fullName = userProfile.DisplayName ?? username,
                    username = username,
                    bio = userProfile.Bio ?? "MapMe user",
                    location = userProfile.Location ?? "Location not specified",
                    website = (string?)null,
                    joinedAt = userProfile.CreatedAt.ToString("MMM yyyy"),
                    followers = 0, // Not implemented yet
                    following = 0, // Not implemented yet
                    photosCount = userProfile.Photos?.Count ?? 0,
                    interests = userProfile.Interests?.Take(5).ToArray() ?? new string[0],
                    avatar = userProfile.Photos?.FirstOrDefault()?.Url ?? "/images/user-avatar.svg",
                    age = userProfile.Age,
                    gender = userProfile.Gender,
                    totalDateMarks = activityStats.TotalDateMarks,
                    uniqueCategories = activityStats.UniqueCategories,
                    averageRating = activityStats.AverageRating
                };
            }
            
            // Fallback for unknown users
            return new
            {
                fullName = username,
                username = username,
                bio = "MapMe user",
                location = "Location not specified",
                website = (string?)null,
                joinedAt = "Recently",
                followers = 0,
                following = 0,
                photosCount = 0,
                interests = new string[0],
                avatar = "/images/user-avatar.svg"
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in GetUserProfileForJS: {ex.Message}");
            return null;
        }
    }

    private async Task HandleQueryParameters()
    {
        var uri = new Uri(Navigation.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        
        if (double.TryParse(query["lat"], out var lat) && 
            double.TryParse(query["lng"], out var lng))
        {
            _latitude = lat;
            _longitude = lng;
            
            if (int.TryParse(query["zoom"], out var zoom))
            {
                _zoom = zoom;
            }
            else
            {
                _zoom = 15; // Default zoom when navigating to specific location
            }
        }
    }

    private async Task InitializeMap()
    {
        try
        {
            _dotNetHelper = DotNetObjectReference.Create(this);
            _mapModule = await JsRuntime.InvokeAsync<IJSObjectReference>(
                "import", 
                "/js/mapInitializer.js");
            
            // Fetch Google Maps API key from server configuration endpoint
            try
            {
                var cfg = await Http.GetFromJsonAsync<MapConfig>("/config/maps");
                _googleMapsApiKey = cfg?.ApiKey;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to retrieve Maps API key: {ex.Message}");
            }
                
            // Try to get user's current location first
            try
            {
                var location = await GetCurrentLocationAsync();
                _latitude = location.Lat;
                _longitude = location.Lng;
                _zoom = 15; // Zoom in more when using current location
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Geolocation error: {ex.Message}. Using default location.");
                // Use default location (Singapore)
            }
            
            await _mapModule.InvokeVoidAsync(
                "initMap", 
                _dotNetHelper, 
                "map", 
                _latitude, 
                _longitude, 
                _zoom, 
                _mapType,
                _googleMapsApiKey);
                
            // Load any existing marks from localStorage
            await LoadMarksAsync();

            // Render existing marks on the map with custom icons
            await SyncMarksToMap();

            _isLoading = false;
            StateHasChanged();
        }
        catch (JSDisconnectedException)
        {
            // Occurs during prerender or when the circuit/browser connection is gone.
            // Swallow to avoid "no browser renderer" errors.
            return;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
            _isLoading = false;
            try { StateHasChanged(); } catch { /* ignore if renderer is gone */ }
        }
    }
    
    private async Task<Location> GetCurrentLocationAsync()
    {
        try
        {
            var position = await JsRuntime.InvokeAsync<GeolocationPosition>("getCurrentPosition");
            
            if (position?.Coords == null)
            {
                Console.WriteLine("Received null or incomplete geolocation data");
                throw new Exception("Could not retrieve geolocation data");
            }
            
            return new Location 
            { 
                Lat = position.Coords.Latitude, 
                Lng = position.Coords.Longitude 
            };
        }
        catch (JSException jsex)
        {
            Console.WriteLine($"JavaScript error getting current location: {jsex.Message}");
            // Return default location (Singapore) if geolocation fails
            return new Location 
            { 
                Lat = 1.3521, 
                Lng = 103.8198 
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting current location: {ex.Message}");
            // Return default location (Singapore) if geolocation fails
            return new Location 
            { 
                Lat = 1.3521, 
                Lng = 103.8198 
            };
        }
    }
    
    private class GeolocationPosition
    {
        public GeolocationCoordinates? Coords { get; set; }
        public long Timestamp { get; set; }
    }
    
    private class GeolocationCoordinates
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public double? Altitude { get; set; }
        public double Accuracy { get; set; }
        public double? AltitudeAccuracy { get; set; }
        public double? Heading { get; set; }
        public double? Speed { get; set; }
    }
    
    public class Location
    {
        public double Lat { get; set; }
        public double Lng { get; set; }
    }

    private async Task CenterMap()
    {
        try
        {
            if (_mapModule != null)
            {
                // Always recenter to the user's current geolocation
                var location = await GetCurrentLocationAsync();
                _latitude = location.Lat;
                _longitude = location.Lng;
                _zoom = 15; // Zoom in more when using current location

                // Set the center on the already-initialized map
                await _mapModule.InvokeVoidAsync("setCenter",
                    _latitude,
                    _longitude,
                    _zoom);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error centering map: {ex.Message}");
        }
    }

    private async Task SearchLocation()
    {
        if (string.IsNullOrWhiteSpace(_searchQuery) || _mapModule == null) 
        {
            Console.WriteLine("Search query is empty or map module is not initialized");
            return;
        }
        
        try
        {
            try
            {
                Console.WriteLine($"Searching for location: {_searchQuery}");
                
                // Then call the search function
                var result = await _mapModule.InvokeAsync<SearchResult>("searchLocation", _searchQuery);
                
                if (result != null && result.Latitude != 0 && result.Longitude != 0)
                {
                    Console.WriteLine($"Found location: {result.Name} at {result.Latitude}, {result.Longitude}");
                    _latitude = result.Latitude;
                    _longitude = result.Longitude;
                    _zoom = 16; // Zoom in more when searching for a location
                    
                    // Update the map center
                    await _mapModule.InvokeVoidAsync("setCenter", _latitude, _longitude, _zoom);
                    
                    // Update the UI to show the new position
                    StateHasChanged();
                }
                else
                {
                    // Show error to user
                    Console.WriteLine($"Location '{_searchQuery}' not found. Please try a different search term.");
                }
            }
            catch (JSException jsex)
            {
                Console.WriteLine($"JavaScript error during search: {jsex.Message}");
                Console.WriteLine($"Stack trace: {jsex.StackTrace}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during search: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SearchLocation: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
        finally
        {
            // No-op: keep map visible during search to avoid layout glitches
        }
    }

    private async Task OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SearchLocation();
        }
    }
    
    private class SearchResult
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public string? Name { get; set; }
        public string? Address { get; set; }
    }

    private class MapConfig
    {
        public string? ApiKey { get; set; }
    }

    // Reverse geocode result shape from JS
    private class ReverseGeocodeResult
    {
        public string? Name { get; set; }
        public string? Address { get; set; }
        public string? PlaceId { get; set; }
        public string? Url { get; set; }
        public List<string>? Types { get; set; }
        // Note: Google Maps JS Places Photo objects do not expose photo_reference.
        // For long-term stable images, use Places Details (Web Service) server-side
        // to fetch photo_reference values and generate URLs on demand.
        public List<string>? PhotoReferences { get; set; }
        public string? PlacePhotoUrl { get; set; }
        public List<string>? PlacePhotoUrls { get; set; }
    }

    // DTO from JS Places getDetails
    public class PlaceDetailsDto
    {
        public string? PlaceId { get; set; }
        public string? Name { get; set; }
        // Matches JS payload: { location: { lat: number, lng: number } }
        public PlaceLocationDto? Location { get; set; }
        public List<string>? Types { get; set; }
        public string? Url { get; set; }
        // See note above: JS does not expose photo_reference. Keep placeholders.
        public List<string>? PhotoReferences { get; set; }
        public string? Address { get; set; }
        public string? PlacePhotoUrl { get; set; }
        public List<string>? PlacePhotoUrls { get; set; }
    }

    public class PlaceLocationDto
    {
        public double Lat { get; set; }
        public double Lng { get; set; }
    }

    // Called from JS when map is clicked
    [JSInvokable]
    public async Task OnMapClick(double lat, double lng)
    {
        await BeginConfirmAsync(lat, lng);
    }

    // Called from JS when marker drag ends
    [JSInvokable]
    public async Task OnMarkerDragEnd(double lat, double lng)
    {
        await BeginConfirmAsync(lat, lng);
    }

    // Called from JS when a POI was clicked and details are available
    [JSInvokable]
    public Task OnPlaceDetails(PlaceDetailsDto details)
    {
        if (details?.Location != null)
        {
            _pendingLat = details.Location.Lat;
            _pendingLng = details.Location.Lng;
        }
        else
        {
            // Fallback to 0/0 if missing; user may cancel
            _pendingLat = 0;
            _pendingLng = 0;
        }

        _pendingNote = string.Empty;
        _pendingGeo = new ReverseGeocodeResult
        {
            Name = details?.Name,
            Address = details?.Address,
            PlaceId = details?.PlaceId,
            Url = details?.Url,
            Types = details?.Types,
            PhotoReferences = details?.PhotoReferences,
            PlacePhotoUrl = details?.PlacePhotoUrl,
            PlacePhotoUrls = details?.PlacePhotoUrls
        };
        _showConfirm = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task BeginConfirmAsync(double lat, double lng)
    {
        _pendingLat = lat;
        _pendingLng = lng;
        _pendingNote = string.Empty;
        _pendingGeo = null;
        try
        {
            if (_mapModule != null)
            {
                _pendingGeo = await _mapModule.InvokeAsync<ReverseGeocodeResult>("reverseGeocode", lat, lng);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"reverseGeocode failed: {ex.Message}");
        }
        _showConfirm = true;
        StateHasChanged();
    }

    private void CancelConfirm()
    {
        _showConfirm = false;
        _pendingNote = string.Empty;
        _pendingGeo = null;
    }

    private async Task ConfirmSave()
    {
        _showConfirm = false;
        await SaveMarkAsync(_pendingLat, _pendingLng, _pendingNote, _pendingGeo);
        _pendingNote = string.Empty;
        _pendingGeo = null;
    }

    private async Task SaveMarkAsync(double lat, double lng, string note, ReverseGeocodeResult? geocoded)
    {
        try
        {
            geocoded ??= _mapModule != null
                ? await _mapModule.InvokeAsync<ReverseGeocodeResult>("reverseGeocode", lat, lng)
                : null;

            var mark = new DateMark
            {
                Id = Guid.NewGuid().ToString(),
                UserId = _currentUserProfile.UserId,
                Latitude = lat,
                Longitude = lng,
                Name = geocoded?.Name,
                Address = geocoded?.Address,
                PlaceId = geocoded?.PlaceId,
                Note = string.IsNullOrWhiteSpace(note) ? null : note,
                Types = geocoded?.Types,
                Url = geocoded?.Url,
                PhotoReferences = geocoded?.PhotoReferences,
                PlacePhotoUrl = geocoded?.PlacePhotoUrl,
                PlacePhotoUrls = geocoded?.PlacePhotoUrls,
                UserPhotoUrl = _currentUserProfile.Photos?.FirstOrDefault()?.Url ?? "/images/user-avatar.svg",
                UserPhotoUrls = _currentUserProfile.Photos?.Select(p => p.Url).ToList() ?? new List<string>(),
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            // Use the ProfileService to save the DateMark with duplicate checking
            var (success, existingMark) = await ProfileService.SaveDateMarkAsync(mark);
            
            if (success)
            {
                _savedMarks.Insert(0, mark);
                await SyncMarksToMap();
                StateHasChanged();
            }
            else if (existingMark != null)
            {
                // Duplicate found, navigate to edit the existing mark
                Navigation.NavigateTo($"/map?lat={existingMark.Latitude}&lng={existingMark.Longitude}&zoom=15&edit={existingMark.Id}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving mark: {ex.Message}");
        }
    }

    private async Task LoadMarksAsync()
    {
        try
        {
            _savedMarks.Clear();
            var userMarks = await ProfileService.GetUserDateMarksAsync(_currentUserProfile.UserId);
            _savedMarks.AddRange(userMarks.OrderByDescending(m => m.CreatedAt));
            await SyncMarksToMap();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading marks: {ex.Message}");
        }
    }

    private async Task FlyTo(DateMark mark)
    {
        try
        {
            if (_mapModule != null)
            {
                await _mapModule.InvokeVoidAsync("setCenter", mark.Latitude, mark.Longitude, 17);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error flying to mark: {ex.Message}");
        }
    }

    private async Task RemoveMark(DateMark mark)
    {
        try
        {
            var success = await ProfileService.DeleteDateMarkAsync(mark.Id);
            if (success)
            {
                _savedMarks.Remove(mark);
                await SyncMarksToMap();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing mark: {ex.Message}");
        }
    }

    private async Task SyncMarksToMap()
    {
        try
        {
            if (_mapModule == null) return;
            var payload = _savedMarks.Select(m => new
            {
                lat = m.Latitude,
                lng = m.Longitude,
                title = !string.IsNullOrWhiteSpace(m.Name) ? m.Name : $"Lat {m.Latitude:F5}, Lng {m.Longitude:F5}",
                address = m.Address,
                note = m.Note,
                createdBy = m.UserId,
                userPhotoUrl = m.UserPhotoUrl,
                userPhotoUrls = m.UserPhotoUrls,
                placePhotoUrl = m.PlacePhotoUrl,
                placePhotoUrls = m.PlacePhotoUrls
            }).ToList();
            await _mapModule.InvokeVoidAsync("renderMarks", payload);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error syncing marks to map: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isDisposed) return;
        
        if (_mapModule != null)
        {
            try
            {
                await _mapModule.InvokeVoidAsync("dispose");
                await _mapModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Handle the case where the JavaScript side is no longer available
            }
            catch
            {
                // Best-effort cleanup
            }
        }
        
        _dotNetHelper?.Dispose();
        _isDisposed = true;
    }
}
