@page "/map"
@page "/"
@using Microsoft.JSInterop
@using System.Net.Http
@using System.Net.Http.Json
@using System.Text.Json
@using System.Linq
@inject IJSRuntime JsRuntime
@inject HttpClient Http
@implements IAsyncDisposable

<PageTitle>Map</PageTitle>

<div class="page">
    <h1>Map</h1>
    
    <div class="mb-3">
        <Badge Color="BadgeColor.Primary">Interactive Map</Badge>
    </div>

    <div class="card">
        <CardHeader>
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                <CardTitle class="mb-0">Map View</CardTitle>
                <div class="d-flex gap-2">
                    <div class="search-container">
                        <div class="input-group">
                            <input type="text" 
                                   class="form-control" 
                                   placeholder="Search location..." 
                                   @bind="_searchQuery"
                                   @onkeyup="OnSearchKeyUp" />
                            <Button Color="ButtonColor.Primary" 
                                    @onclick="SearchLocation" 
                                    Disabled="@(_isLoading || string.IsNullOrWhiteSpace(_searchQuery))">
                                <i class="bi bi-search"></i>
                            </Button>
                        </div>
                    </div>
                    <Button Color="ButtonColor.Primary" 
                            Outline="true" 
                            Size="ButtonSize.Small" 
                            @onclick="CenterMap" 
                            Disabled="@_isLoading">
                        @(_isLoading ? "Loading..." : "Center Map")
                    </Button>
                </div>
            </div>
        </CardHeader>
        <CardBody>
            @if (_isLoading)
            {
                <div class="d-flex justify-content-center align-items-center" style="height: 600px;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading map...</span>
                    </div>
                    <span class="ms-2">Loading map and getting your location...</span>
                </div>
            }
            <div id="map" style="height: 600px; border-radius: 4px; overflow: hidden; @(_isLoading ? "display: none;" : "") "></div>
        </CardBody>
    </div>

    @if (_showConfirm)
    {
        <div class="modal fade show" style="display:block; background: rgba(0,0,0,0.5);" tabindex="-1" role="dialog">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Save MarkDate</h5>
                        <button type="button" class="btn-close" aria-label="Close" @onclick="CancelConfirm"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-2"><strong>Location</strong></div>
                        <div class="small text-muted mb-2">@(_pendingGeo?.Name ?? _pendingGeo?.Address ?? ($"Lat {_pendingLat:F5}, Lng {_pendingLng:F5}"))</div>
                        <div class="mb-2"><strong>Address</strong></div>
                        <div class="small text-muted mb-3">@_pendingGeo?.Address</div>
                        <div class="mb-2"><strong>Note</strong></div>
                        <textarea class="form-control" rows="3" @bind="_pendingNote" placeholder="Add a note..."></textarea>
                    </div>
                    <div class="modal-footer">
                        <Button Color="ButtonColor.Secondary" Outline="true" @onclick="CancelConfirm">Cancel</Button>
                        <Button Color="ButtonColor.Primary" @onclick="ConfirmSaveAsync">Save</Button>
                    </div>
                </div>
            </div>
        </div>
    }

    <div class="card mt-3">
        <CardHeader>
            <CardTitle class="mb-0">Saved MarkDates (local)</CardTitle>
        </CardHeader>
        <CardBody>
            @if (_savedMarks.Count == 0)
            {
                <div class="text-muted">No marks saved yet. Click on the map or drag the marker to add one.</div>
            }
            else
            {
                <ul class="list-group">
                    @foreach (var m in _savedMarks)
                    {
                        <li class="list-group-item d-flex justify-content-between align-items-start">
                            <div class="me-2">
                                <div class="fw-semibold">@(!string.IsNullOrWhiteSpace(m.Name) ? m.Name : $"Lat {m.Latitude:F5}, Lng {m.Longitude:F5}")</div>
                                <div class="small text-muted">@m.Address</div>
                                <div class="small">By: <span class="text-muted">@m.CreatedBy</span></div>
                                @if (!string.IsNullOrWhiteSpace(m.Note))
                                {
                                    <div class="small">Note: <span class="text-muted">@m.Note</span></div>
                                }
                                <div class="small text-muted">Saved @m.SavedAt.ToLocalTime()</div>
                                @if (!string.IsNullOrWhiteSpace(m.PlaceId))
                                {
                                    <div class="small"><a href="@($"https://www.google.com/maps/place/?q=place_id:{m.PlaceId}")" target="_blank" rel="noopener noreferrer">Open in Google Maps</a></div>
                                }
                            </div>
                            <div class="d-flex gap-2">
                                <Button Size="ButtonSize.Small" Color="ButtonColor.Primary" Outline="true" @onclick="() => FlyTo(m)">View</Button>
                                <Button Size="ButtonSize.Small" Color="ButtonColor.Danger" Outline="true" @onclick="() => RemoveMark(m)">Delete</Button>
                            </div>
                        </li>
                    }
                </ul>
            }
        </CardBody>
    </div>

    <div class="mt-3">
        <Button Color="ButtonColor.Primary" Href="/">Back to Home</Button>
    </div>
</div>

@code {
    private IJSObjectReference? _mapModule;
    private DotNetObjectReference<Map>? _dotNetHelper;
    private double _latitude = 1.3521; // Default to Singapore
    private double _longitude = 103.8198;
    private int _zoom = 12;
    private const string MapElementId = "map";
    private string _mapType = "roadmap";
    private bool _isLoading = true;
    private bool _isDisposed;
    private string _searchQuery = string.Empty;
    private string? _googleMapsApiKey;
    private const string StorageKey = "markDates";
    private readonly List<MarkDate> _savedMarks = new();
    private bool _showConfirm;
    private double _pendingLat;
    private double _pendingLng;
    private ReverseGeocodeResult? _pendingGeo;
    private string _pendingNote = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeMap();
        }
    }

    private async Task InitializeMap()
    {
        try
        {
            _dotNetHelper = DotNetObjectReference.Create(this);
            _mapModule = await JsRuntime.InvokeAsync<IJSObjectReference>(
                "import", 
                "/js/mapInitializer.js");
            
            // Fetch Google Maps API key from server configuration endpoint
            try
            {
                var cfg = await Http.GetFromJsonAsync<MapConfig>("/config/maps");
                _googleMapsApiKey = cfg?.ApiKey;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to retrieve Maps API key: {ex.Message}");
            }
                
            // Try to get user's current location first
            try
            {
                var location = await GetCurrentLocationAsync();
                _latitude = location.Latitude;
                _longitude = location.Longitude;
                _zoom = 15; // Zoom in more when using current location
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Geolocation error: {ex.Message}. Using default location.");
                // Use default location (Singapore)
            }
            
            await _mapModule.InvokeVoidAsync(
                "initMap", 
                _dotNetHelper, 
                MapElementId, 
                _latitude, 
                _longitude, 
                _zoom, 
                _mapType,
                _googleMapsApiKey);
                
            // Load any existing marks from localStorage
            await LoadMarksAsync();

            // Render existing marks on the map with custom icons
            await SyncMarksToMap();

            _isLoading = false;
            StateHasChanged();
        }
        catch (JSDisconnectedException)
        {
            // Occurs during prerender or when the circuit/browser connection is gone.
            // Swallow to avoid "no browser renderer" errors.
            return;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
            _isLoading = false;
            try { StateHasChanged(); } catch { /* ignore if renderer is gone */ }
        }
    }
    
    private async Task<Location> GetCurrentLocationAsync()
    {
        try
        {
            var position = await JsRuntime.InvokeAsync<GeolocationPosition>("getCurrentPosition");
            
            if (position?.Coords == null)
            {
                Console.WriteLine("Received null or incomplete geolocation data");
                throw new Exception("Could not retrieve geolocation data");
            }
            
            return new Location 
            { 
                Latitude = position.Coords.Latitude, 
                Longitude = position.Coords.Longitude 
            };
        }
        catch (JSException jsex)
        {
            Console.WriteLine($"JavaScript error getting current location: {jsex.Message}");
            // Return default location (Singapore) if geolocation fails
            return new Location 
            { 
                Latitude = 1.3521, 
                Longitude = 103.8198 
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting current location: {ex.Message}");
            // Return default location (Singapore) if geolocation fails
            return new Location 
            { 
                Latitude = 1.3521, 
                Longitude = 103.8198 
            };
        }
    }
    
    private class GeolocationPosition
    {
        public GeolocationCoordinates? Coords { get; set; }
        public long Timestamp { get; set; }
    }
    
    private class GeolocationCoordinates
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public double? Altitude { get; set; }
        public double Accuracy { get; set; }
        public double? AltitudeAccuracy { get; set; }
        public double? Heading { get; set; }
        public double? Speed { get; set; }
    }
    
    public class Location
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
    }

    private async Task CenterMap()
    {
        try
        {
            if (_mapModule != null)
            {
                // Always recenter to the user's current geolocation
                var location = await GetCurrentLocationAsync();
                _latitude = location.Latitude;
                _longitude = location.Longitude;
                _zoom = 15; // reasonable zoom for current location

                // Set the center on the already-initialized map
                await _mapModule.InvokeVoidAsync("setCenter",
                    _latitude,
                    _longitude,
                    _zoom);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error centering map: {ex.Message}");
        }
    }

    private async Task SearchLocation()
    {
        if (string.IsNullOrWhiteSpace(_searchQuery) || _mapModule == null) 
        {
            Console.WriteLine("Search query is empty or map module is not initialized");
            return;
        }
        
        try
        {
            try
            {
                Console.WriteLine($"Searching for location: {_searchQuery}");
                
                // Then call the search function
                var result = await _mapModule.InvokeAsync<SearchResult>("searchLocation", _searchQuery);
                
                if (result != null && result.Latitude != 0 && result.Longitude != 0)
                {
                    Console.WriteLine($"Found location: {result.Name} at {result.Latitude}, {result.Longitude}");
                    _latitude = result.Latitude;
                    _longitude = result.Longitude;
                    _zoom = 16; // Zoom in more when searching for a location
                    
                    // Update the map center
                    await _mapModule.InvokeVoidAsync("setCenter", _latitude, _longitude, _zoom);
                    
                    // Update the UI to show the new position
                    StateHasChanged();
                }
                else
                {
                    // Show error to user
                    Console.WriteLine($"Location '{_searchQuery}' not found. Please try a different search term.");
                }
            }
            catch (JSException jex)
            {
                Console.WriteLine($"JavaScript error during search: {jex.Message}");
                Console.WriteLine($"Stack trace: {jex.StackTrace}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during search: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SearchLocation: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
        finally
        {
            // No-op: keep map visible during search to avoid layout glitches
        }
    }

    private async Task OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SearchLocation();
        }
    }
    
    private class SearchResult
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public string? Name { get; set; }
        public string? Address { get; set; }
    }

    private class MapConfig
    {
        public string? ApiKey { get; set; }
    }

    // Reverse geocode result shape from JS
    private class ReverseGeocodeResult
    {
        public string? Name { get; set; }
        public string? Address { get; set; }
        public string? PlaceId { get; set; }
        public string? Url { get; set; }
        public List<string>? Types { get; set; }
        // Note: Google Maps JS Places Photo objects do not expose photo_reference.
        // For long-term stable images, use Places Details (Web Service) server-side
        // to fetch photo_reference values and generate URLs on demand.
        public List<string>? PhotoReferences { get; set; }
        public string? PlacePhotoUrl { get; set; }
    }

    // DTO from JS Places getDetails
    public class PlaceDetailsDto
    {
        public string? PlaceId { get; set; }
        public string? Name { get; set; }
        // Matches JS payload: { location: { lat: number, lng: number } }
        public PlaceLocationDto? Location { get; set; }
        public List<string>? Types { get; set; }
        public string? Url { get; set; }
        // See note above: JS does not expose photo_reference. Keep placeholders.
        public List<string>? PhotoReferences { get; set; }
        public string? Address { get; set; }
        public string? PlacePhotoUrl { get; set; }
    }

    public class PlaceLocationDto
    {
        public double Lat { get; set; }
        public double Lng { get; set; }
    }

    public class MarkDate
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public string? Name { get; set; }
        public string? Address { get; set; }
        public string? PlaceId { get; set; }
        public string CreatedBy { get; set; } = "current user";
        public string? Note { get; set; }
        public List<string>? Types { get; set; }
        public string? Url { get; set; }
        // Store photo_reference values if obtained via backend.
        public List<string>? PhotoReferences { get; set; }
        public string? PlacePhotoUrl { get; set; }
        public string? UserPhotoUrl { get; set; }
        public DateTime SavedAt { get; set; }
    }

    // Called from JS when map is clicked
    [JSInvokable]
    public async Task OnMapClick(double lat, double lng)
    {
        await BeginConfirmAsync(lat, lng);
    }

    // Called from JS when marker drag ends
    [JSInvokable]
    public async Task OnMarkerDragEnd(double lat, double lng)
    {
        await BeginConfirmAsync(lat, lng);
    }

    // Called from JS when a POI was clicked and details are available
    [JSInvokable]
    public Task OnPlaceDetails(PlaceDetailsDto details)
    {
        if (details?.Location != null)
        {
            _pendingLat = details.Location.Lat;
            _pendingLng = details.Location.Lng;
        }
        else
        {
            // Fallback to 0/0 if missing; user may cancel
            _pendingLat = 0;
            _pendingLng = 0;
        }

        _pendingNote = string.Empty;
        _pendingGeo = new ReverseGeocodeResult
        {
            Name = details?.Name,
            Address = details?.Address,
            PlaceId = details?.PlaceId,
            Url = details?.Url,
            Types = details?.Types,
            PhotoReferences = details?.PhotoReferences,
            PlacePhotoUrl = details?.PlacePhotoUrl
        };
        _showConfirm = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task BeginConfirmAsync(double lat, double lng)
    {
        _pendingLat = lat;
        _pendingLng = lng;
        _pendingNote = string.Empty;
        _pendingGeo = null;
        try
        {
            if (_mapModule != null)
            {
                _pendingGeo = await _mapModule.InvokeAsync<ReverseGeocodeResult>("reverseGeocode", lat, lng);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"reverseGeocode failed: {ex.Message}");
        }
        _showConfirm = true;
        StateHasChanged();
    }

    private void CancelConfirm()
    {
        _showConfirm = false;
        _pendingNote = string.Empty;
        _pendingGeo = null;
    }

    private async Task ConfirmSaveAsync()
    {
        _showConfirm = false;
        await SaveMarkAsync(_pendingLat, _pendingLng, _pendingNote, _pendingGeo);
        _pendingNote = string.Empty;
        _pendingGeo = null;
    }

    private async Task SaveMarkAsync(double lat, double lng, string? note = null, ReverseGeocodeResult? geocoded = null)
    {
        try
        {
            geocoded ??= _mapModule != null
                ? await _mapModule.InvokeAsync<ReverseGeocodeResult>("reverseGeocode", lat, lng)
                : null;

            var mark = new MarkDate
            {
                Latitude = lat,
                Longitude = lng,
                Name = geocoded?.Name,
                Address = geocoded?.Address,
                PlaceId = geocoded?.PlaceId,
                Note = string.IsNullOrWhiteSpace(note) ? null : note,
                Types = geocoded?.Types,
                Url = geocoded?.Url,
                PhotoReferences = geocoded?.PhotoReferences,
                PlacePhotoUrl = geocoded?.PlacePhotoUrl,
                // TODO: Populate with real user profile photo if available
                UserPhotoUrl = null,
                SavedAt = DateTime.UtcNow
            };

            _savedMarks.Insert(0, mark);
            await PersistMarksAsync();
            await SyncMarksToMap();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving mark: {ex.Message}");
        }
    }

    private async Task LoadMarksAsync()
    {
        try
        {
            var json = await JsRuntime.InvokeAsync<string?>("MapMe.storage.load", StorageKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var loaded = JsonSerializer.Deserialize<List<MarkDate>>(json) ?? new List<MarkDate>();
                _savedMarks.Clear();
                _savedMarks.AddRange(loaded.OrderByDescending(m => m.SavedAt));
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading marks: {ex.Message}");
        }
    }

    private async Task PersistMarksAsync()
    {
        try
        {
            var json = JsonSerializer.Serialize(_savedMarks);
            await JsRuntime.InvokeVoidAsync("MapMe.storage.save", StorageKey, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error persisting marks: {ex.Message}");
        }
    }

    private async Task FlyTo(MarkDate mark)
    {
        try
        {
            if (_mapModule != null)
            {
                await _mapModule.InvokeVoidAsync("setCenter", mark.Latitude, mark.Longitude, 17);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error flying to mark: {ex.Message}");
        }
    }

    private async Task RemoveMark(MarkDate mark)
    {
        _savedMarks.Remove(mark);
        await PersistMarksAsync();
        await SyncMarksToMap();
        StateHasChanged();
    }

    private async Task SyncMarksToMap()
    {
        try
        {
            if (_mapModule == null) return;
            var payload = _savedMarks.Select(m => new
            {
                lat = m.Latitude,
                lng = m.Longitude,
                title = !string.IsNullOrWhiteSpace(m.Name) ? m.Name : $"Lat {m.Latitude:F5}, Lng {m.Longitude:F5}",
                address = m.Address,
                note = m.Note,
                createdBy = m.CreatedBy,
                userPhotoUrl = m.UserPhotoUrl,
                placePhotoUrl = m.PlacePhotoUrl
            }).ToList();
            await _mapModule.InvokeVoidAsync("renderMarks", payload);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error syncing marks to map: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isDisposed) return;
        
        if (_mapModule != null)
        {
            try
            {
                await _mapModule.InvokeVoidAsync("dispose");
                await _mapModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Handle the case where the JavaScript side is no longer available
            }
            catch
            {
                // Best-effort cleanup
            }
        }
        
        _dotNetHelper?.Dispose();
        _isDisposed = true;
    }
}
